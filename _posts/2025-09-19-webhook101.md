---
title: Webhooks: do básico à resiliência
date: 2025-09-18 23:37:28
tags:
---
Webhooks, postback, notificação reversa entre sistemas, muitos nomes pro mesmo proposito: notificar sistemas parceiros/dependentes de novos eventos. 

Das varias empresa que passei, quase todas em algum momento lidei com webhook, muitas vezes no contexto de pagamento: receber notificação de venda por Pix e receber notificações sobre assinaturas gerenciadas por um Gateway são atividades muitos comuns de quase todo SaaS. Ainda assim, nem todo dev lida com essas integrações com o cuidado que elas exigem.

# Estrutura base

Talvez o maior ponto de um webhook seja sua resiliencia perante um cenário muito incerto: outra aplicação está disparando ações na nossa aplicação se baseando apenas em contrato previamento definido. Os dados podem chegar via URL ou no corpo (body) da requisição HTTP, e devem ser validados antes de prosseguir para uma operação. O um status code de resposta indica para a aplicação que enviou se a operação foi bem-sucedida ou se vai ser necessário a re-tentativa.

Requisição -> Validação de dados -> Processamento -> Resposta

# Problemas frequentes

Vamos separar os problemas em duas categorias: conceituais e críticos.

## Conceitual

Geralmente quando desenhamos uma API, usamos o recurso para expor a ação (exemplo: GET para buscar) e o dominio (entidade) para definir quem vai ser afetado pela ação. Uma API RESTful comum seria:

- GET /users

Webhooks não precisam seguir RESTful como se fosse uma comunicação externa do sistema, baseada em recursos. É muito comum, na verdade, vermos webhooks que trabalham todas suas ações via POST. O mais importante vai ser o contrato, e definir o evento que o sistema está notificando (e que nosso sistema está recebendo).

É muito comum entre os dados termos um campo "event", informando a ação notificada de forma direta, por exemplo:

Duas formas comuns de compor um webhook:

- nome da API com ação de forma geral + evento detalhado no corpo da requisição

POST /credit-card-payment-notification
```json
{
    "event": "approved"
}
```

ou

```json
{
    "event": "rejected"
}
```

- nome da API com ação detalhada + status do evento esperado

POST /payment-accepted-postback
```json
{
    "event": "success"
}
```

ou

```json
{
    "event": "fail"
}
```

No contexto de webhooks é mais comum a utlização de um nome que referencie o caso de uso, além de informar explicitamente que é um webhook através de termos consolidados como `webhook` ou `postback` ou implicitamente com algum termo que remeta a ser notificado, como `notification` e `notify`. Alguns API de webhook comuns seriam:

- POST /credit-card-payment-notification
- POST /payment-processed-webhook
- POST /payment-accepted-postback

Os status codes mais comuns de vermos em webhooks, e que provavelmente vamos usar no nosso:

- 2xx: sucesso, tudo conforme o esperado.
- 401: algo falhou na autenticação.
- 400: dados malformatados *
- 5xx: falhas do lado do nosso sistema

* Pode ter grande variação entre sistemas na faixa do 4xx, alguns sistemas vão detalhar, utilizando 404 para um recurso não encontrado, outros vão utilizar 400 considerando que um recurso não encontrado foge do acordo de envio de dados validos. Se atente ao como quer lidar no seu webhook, e principalmente como os webhooks que você utiliza lida com os status code da faixa 4xx.
 
## Critico

Aqui vão estar as race conditions, consumo de recurso em execuções duplicadas, gargalos de escalabilidade e roubo de recurso de peças que não podem processar em background.

### Race conditions

Sempre usamos o exemplo de duas operações acontecendo ao mesmo tempo em uma conta bancaria, dois saques.

Vou usar um exemplo mais simples dessa vez: se você não alterou as regras padrões de LOCK do seu banco de daods, não implementou checagens de duplicação transacionais, e um mesmo webhook chegar três vezes na aplicação, o que acontece?

Se seu webhook pega o dado e já processa, a validação de duplicidade pode não ser suficiente. Antes que a primeira requesição registre os dados no banco, a segunda requesição pode já ter passado pela checagem de duplicidade. Isso acontece porque sem LOCKs ou validação transacional, requisições concorrentes não estarão se "enxergando", o tempo de busca no banco para validar duplicação no código é lento (em termos de sistema), então as requisições seriam processadas como únicas em todo o fluxo.

Para solucionar, devemos validar unicidade dos dados a nivel de tabela do banco de dados, e se possível implementar LOCKs no nosso banco de dados.

Uma solução rapida que pode resolver seu problema inicialmente é adicionar uma fila nesse webhook, toda requesição seria processada de forma ordenada (FIFO), e você consegue controlar concorrência e delay. Essa solução é boa principalmente se a notificação não precisa ser consumida em tempo real/baixo intervalo.

### Consumo de recursos por operações duplicadas

Já entendemos que se não nos precavermos a nível transacional no nosso banco de dados, podemos ter algumas inconsistências e dados duplicados, mas mesmo com essas precauções a requisição só será encerrada ao tentar processar um dado duplicado no banco, consumindo recurso até esse ponto.

A solução clássica: rate limit por requisição.

Pode ser feito de várias formas, mas a chave é a utilização de um banco de acesso de dados, não de persistência, reduzindo drasticamente a latência ao validar se uma requisição já foi processada.

Essa parte é simples: se usamos checagem para impedir processamento duplicado, não podemos demorar possibilitando duplicações durante o carregamento do dado.

Uma técnica para manter a segurança e ainda assim impedir processamento de requesições iguais é criar uma hash do corpo da requisição e armazenar temporariamente. Antes de todo processamento, validamos se a hash não existe, impedindo uma requisição igual de executar novamente. 

Recomendo:
- Tempo de expiração: 60 segundos, permitindo a re-tentativa após o período.
- Registro de todas as requisições: sucesso ou falha, nada será re-processado dentro de 1 minuto.
- Registro em cache: com baixa latência para não possibilitar duplicações durante a checagem

Dessa forma, impesso o processamento de um spam acidental do cliente, permito a re-tentativa após 60 segundos e evito sobrecarga desnecessária no sistema.