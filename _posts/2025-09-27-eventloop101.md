---
title: "Desvendando Node.js: Event Loop e Armadilhas"
date: 2025-09-27 03:03:28
tags:
---

# Event Loop

Falar de event loop é pré-requisito quando planejamos (e até mesmo executamos) aplicações escaláveis com Node.js, vejo muitas alusões (como usar o exemplo do  while(true)) e tentavivas de tornar mais "humano" (como usar o exemplo da fila), mas vou seguir pra algo utilizando os nomes propriamente.

Acredito que o mais dificil seja a quantidade de peças que precisamos encaixar nesse quebra-cabeça, então vamos separar o que vemos sendo chamado de event loop em seus devidos passos, todo processo de execução assincrono de um programa utilizando o Node.js seguirá esse caminho:

- entrar na call stack
- sair da call stack e delegar execução assincrona para o ambiente do Node.js
- quando finalizado, o resultado é colocado na task queue (para callbacks comuns e operações de I/O)
- em caso de promise, o resultado vai para a microtask queue

* event loop checa se não tem nada na microtask queue antes de adicionar uma execução da task queue no call stack

E todo processamento sincrono seguirá esse caminho:

- entrar na call stack
- sair da call stack e executar

Entendendo as peças

Bom, agora conhecemos os nomes e temos um conhecimento insuficiente do que cada um faz, então vamos aprofundar.

# Call stack

A call stack, em tradução pilha de chamada, é uma fila de execuções. O Node.js é desenvolvido utilizando a Libuv, que é single-threaded, o que facilita entender essa pilha, não temos operações em paralelo, temos uma chamada após a outra.

Mas existe uma pegadinha: quando falamos que uma chamada é após a outra, não quer dizer o código roda de forma sequencial até o fim, quer dizer que a call stack delega, de maneira síncrona, para as outras estruturas (como task queue e microtask queue).

No exemplo a seguir temos duas execuções que entram sequencialmente e são endereçadas dessa forma, mas não executam nessa sequencia:

```typescript

setTimeout(() => console.log("Estou no setTimeout"), 100)

Promise.resolve().then(() => console.log("Estou na Promise"))

console.log("Estou após a Promise e o setTimeout")
```

Isso nos gera o seguinte output:

```bash
Estou após a Promise e o setTimeout
Estou na Promise
Estou no setTimeout
```

A explicação pra isso é: 

- o setTimeout entrará na call stack, e será prontamente direcionado a execução em background (usando Node.js para gerenciar o tempo "fisico").

- o Promise.resolve() entrará na call stack e será prontamente executado, mas o callback .then() será delegado ao microtask queue

- o event loop esvaziará a microtask queue

- `console.log("Estou após o setTimeout")` entrará na call stack, e será executado, pois é sincrono. 

- após 100ms a execução do `console.log("Estou no setTimeout")` irá para a task queue

- por fim o event loop esvaziará a task queue, adicionando ao call stack para ser executado.

# Riscos

Quando comecei a utilizar Node.js, escutei muito sobre ser não bloqueante em termos de I/O, e isso, com certeza, me gerou confusão. Outro problema que tive com termos foi quando escutava sobre as opções para "multi-threading" com Node.js e pensava ser algo da estrutura. Vamos entender esses dois conceitos e como isso leva nossos sistemas a grandes falhas.

## Non-blocking I/O

Como vimos na explicação do event loop, operações de I/O saem do call stack e são delegadas para processamento em background, enquanto a call stack segue livre para executar novas chamadas. 

Quando a operação de I/O é concluída, a callback associada é colocada na task queue ou, se estiver ligada a uma Promise, na microtask queue, aguardando sua vez de ser executada pelo event loop. 

Com isso, conseguimos ler o disco, fazer chamadas de rede, utilizar timers, entre outras operações assíncronas, sem bloquear nossa call stack de processar e endereçar novas chamadas.


## Single-threaded

Aqui talvez venha a maior confusão: o Node.js te oferece formas de paralelismo, como Worker Threads, mas a call stack continua sendo single-threaded.

Nesse caso, tudo que entrar e for processado de forma síncrona precisará concluir a execução antes da próxima na call stack. Aqui mora o grande perigo do Node.js:

- Se eu colocar uma chamada ao banco de dados e ela demorar 10s, a operação de I/O é non-blocking, já que o retorno virá via Promise, seguindo a microtask queue; logo, já passamos da call stack, e só voltaremos para entregar a Promise resolvida.

- Se eu colocar uma operação CPU-intensive, como um for-loop para validar se meus 4,5M de usuários têm a letra A no nome e agrupar, a call stack só será liberada para a próxima execução após a conclusão desse for-loop.

# Solução com Worker Threads

Worker threads é uma solução robusta e built-in, tendo como maior critica provavelmente o DX.

(to be continued)
.
.
.